/*******************************************************************************
 * Copyright (c) 2007 Pascal Essiembre.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Pascal Essiembre - initial API and implementation
 *    Christian Behon - some improvements
 ******************************************************************************/
package org.eclipse.e4.babel.core;


import java.util.regex.Pattern;
import org.eclipse.e4.babel.core.preference.PropertyPreferences;
import org.eclipse.e4.babel.editor.model.bundle.Bundle;
import org.eclipse.e4.babel.editor.model.bundle.BundleEntry;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipselabs.e4.tapiji.logger.Log;


public final class PropertyManager {

    private static final String TAG = PropertyManager.class.getSimpleName();
    private static final String SYSTEM_LINE_SEPARATOR = System.getProperty("line.separator");
    private static final String KEY_VALUE_SEPARATORS = "=:";
    private static final String NEW_LINE = "\n";
    private static final String CARRIAGE_RETURN = "\r";
    private static final String BACKSLASH = "\\";


    private static final Pattern PATTERN_LINE_BREAK = Pattern.compile("\r\n|\r|\n");
    private static final Pattern PATTERN_IS_REGULAR_LINE = Pattern.compile("^[^#].*");
    private static final Pattern PATTERN_IS_COMMENTED_LINE = Pattern.compile("^##[^#].*");
    private static final Pattern PATTERN_BACKSLASH_CARRIAGE_RETURN = Pattern.compile("\\\\r");
    private static final Pattern PATTERN_BACKSLASH_NEW_LINE = Pattern.compile("\\\\n");
    private static final Pattern PATTERN_LEADING_SPACE = Pattern.compile("^\\s*");
    private static final Pattern PATTERN_COMMENT_START = Pattern.compile("^##");

    private static final char CHARACTER_BACKSLASH = '\\';
    private static final char CHARACTER_CALL_SIGN = '!';
    private static final char CHARACTER_SIGN = '#';
    private static final char[] HEX_DIGITS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

    private static final String GENERATED_BY = "# Generated by Eclipse Messages Editor (Eclipse Babel)";
    private static final String SPECIAL_VALUE_SAVE_CHARS = "\t\f";
    private static final String SPECIAL_KEY_SAVE_CHARS = "=\t\f#!: ";

    public PropertyManager() {
        super();
    }

    /**
     * Generates a formatted string from a given <code>{@link Bundle}</code>. The returned string will conform to
     * documented properties file structure.
     *
     * @param <tt>MessageBundle</tt> bundle used to generate the content
     * @return <tt>String</tt> The generated content
     */
    public static String generate(final Bundle messageBundle) {
        final StringBuffer text = new StringBuffer();
        return text.toString();
    }


    /**
     * Parses the content from a property file and creates a <code>{@link Bundle}</code>. This
     * <code>{@link Bundle}</code> represents the structure of a property file. The delivered string is expected
     * to match the documents content.
     *
     * @param <tt>String</tt> content from a specific property file to parse
     * @return <tt>PropertyFile</tt> property file structure
     */
    @NonNull
    public Bundle parse(final String content) {
     //   final Bundle messageBundle = Bundle.createInstance();
        if (null != content) {
            final String[] entries = PATTERN_LINE_BREAK.split(content);

            boolean doneWithFileComment = false;
            final StringBuffer fileComment = new StringBuffer();
            final StringBuffer lineComment = new StringBuffer();
            final StringBuffer lineBuf = new StringBuffer();

            final int cnt = entries.length;
            for (int i = 0; i < cnt; i++) {
                final String entry = entries[i];
                lineBuf.setLength(0);
                lineBuf.append(entry);
                int equalPosition = findKeyValueSeparator(entry);
                final boolean isRegularLine = PATTERN_IS_REGULAR_LINE.matcher(entry).matches();
                final boolean isCommentLine = doneWithFileComment && PATTERN_IS_COMMENTED_LINE.matcher(entry).matches();
                if ((equalPosition >= 1) && (isRegularLine || isCommentLine)) {
                    doneWithFileComment = true;
                    String comment = "";
                    if (lineComment.length() > 0) {
                        comment = lineComment.toString();
                        lineComment.setLength(0);
                    }

                    if (isCommentLine) {
                        lineBuf.delete(0, 2);
                        equalPosition -= 2;
                    }

                    while (lineBuf.lastIndexOf(BACKSLASH) == (lineBuf.length() - 1)) {
                        final int lineBreakPosition = lineBuf.lastIndexOf(BACKSLASH);
                        lineBuf.replace(lineBreakPosition, lineBreakPosition + 1, "");
                        if (++i < entries.length) {
                            final String wrappedLine = PATTERN_LEADING_SPACE.matcher(entries[i]).replaceFirst("");
                            if (isCommentLine) {
                                lineBuf.append(PATTERN_COMMENT_START.matcher(entries[i]).replaceFirst(""));
                            } else {
                                lineBuf.append(wrappedLine);
                            }
                        }
                    }
                    String key = unescapeKey(lineBuf.substring(0, equalPosition).trim());
                    String value = PATTERN_LEADING_SPACE.matcher(lineBuf.substring(equalPosition + 1)).replaceFirst("");
                    if (value.startsWith("\\ ")) {
                        value = value.substring(1);
                    }

                    if (PropertyPreferences.getInstance().isConvertUnicodedToEncoded()) {
                        key = convertEncodedToUnicode(key);
                        value = convertEncodedToUnicode(value);
                    } else {
                        value = PATTERN_BACKSLASH_CARRIAGE_RETURN.matcher(value).replaceAll(CARRIAGE_RETURN);
                        value = PATTERN_BACKSLASH_NEW_LINE.matcher(value).replaceAll(NEW_LINE);
                    }
          //          messageBundle.addEntry(BundleEntry.createInstance(key, value, comment, isCommentLine));
                } else if ((lineBuf.length() > 0) && ((lineBuf.charAt(0) == CHARACTER_SIGN) || (lineBuf.charAt(0) == CHARACTER_CALL_SIGN))) {
                    if (!doneWithFileComment) {
                        fileComment.append(lineBuf);
                        fileComment.append(SYSTEM_LINE_SEPARATOR);
                    } else {
                        lineComment.append(lineBuf);
                        lineComment.append(SYSTEM_LINE_SEPARATOR);
                    }
                } else {
                    doneWithFileComment = true;
                }
            }
        }
        return null;
    }

    /**
     * Converts encoded &#92;uxxxx to unicode chars and changes special saved chars to their original forms
     *
     * @param str the string to convert
     * @return converted string
     * @see java.util.Properties
     */
    private String convertEncodedToUnicode(final String str) {
        char aChar;
        final int len = str.length();
        final StringBuffer outBuffer = new StringBuffer(len);

        for (int x = 0; x < len;) {
            aChar = str.charAt(x++);
            if ((aChar == CHARACTER_BACKSLASH) && ((x + 1) <= len)) {
                aChar = str.charAt(x++);
                if ((aChar == 'u') && ((x + 4) <= len)) {
                    // Read the xxxx
                    int value = 0;
                    for (int i = 0; i < 4; i++) {
                        aChar = str.charAt(x++);
                        switch (aChar) {
                            case '0':
                            case '1':
                            case '2':
                            case '3':
                            case '4':
                            case '5':
                            case '6':
                            case '7':
                            case '8':
                            case '9':
                                value = ((value << 4) + aChar) - '0';
                                break;
                            case 'a':
                            case 'b':
                            case 'c':
                            case 'd':
                            case 'e':
                            case 'f':
                                value = ((value << 4) + 10 + aChar) - 'a';
                                break;
                            case 'A':
                            case 'B':
                            case 'C':
                            case 'D':
                            case 'E':
                            case 'F':
                                value = ((value << 4) + 10 + aChar) - 'A';
                                break;
                            default:
                                value = aChar;
                                Log.e(TAG, new Exception("PropertiesDeserializer bad character encoding for string: ".concat(str)));
                        }
                    }
                    outBuffer.append((char) value);
                } else {
                    if (aChar == 't') {
                        aChar = '\t';
                    } else if (aChar == 'r') {
                        aChar = '\r';
                    } else if (aChar == 'n') {
                        aChar = '\n';
                    } else if (aChar == 'f') {
                        aChar = '\f';
                    } else if (aChar == 'u') {
                        outBuffer.append(CHARACTER_BACKSLASH);
                    }
                    outBuffer.append(aChar);
                }
            } else {
                outBuffer.append(aChar);
            }
        }
        return outBuffer.toString();
    }

    /**
     * Finds the separator symbol that separates keys and values.
     *
     * @param str the string on which to find seperator
     * @return the separator index or -1 if no separator was found
     */
    private int findKeyValueSeparator(final String str) {
        int index = -1;
        for (int i = 0, length = str.length(); i < length; i++) {
            final char currentChar = str.charAt(i);
            if (currentChar == CHARACTER_BACKSLASH) {
                i++;
            } else if (KEY_VALUE_SEPARATORS.indexOf(currentChar) != -1) {
                index = i;
                break;
            }
        }
        return index;
    }

    private String unescapeKey(final String key) {
        final StringBuffer buf = new StringBuffer();
        for (final char currentChar : key.toCharArray()) {
            if (currentChar != CHARACTER_BACKSLASH) {
                buf.append(currentChar);
            }
        }
        return buf.toString();
    }

    /**
     * Gets the group from a resource bundle key.
     *
     * @param key the key to get a group from
     * @return key group
     */
    private String getKeyGroup(final String key) {
        final String sep = "";//config.getGroupLevelSeparator();
        final int depth = 0;//config.getGroupLevelDepth();
        int endIndex = 0;
        int levelFound = 0;

        for (int i = 0; i < depth; i++) {
            final int sepIndex = key.indexOf(sep, endIndex);
            if (sepIndex != -1) {
                endIndex = sepIndex + 1;
                levelFound++;
            }
        }
        if (levelFound != 0) {
            if (levelFound < depth) {
                return key;
            }
            return key.substring(0, endIndex - 1);
        }
        return null;
    }


    /**
     * Converts unicodes to encoded &#92;uxxxx.
     *
     * @param str string to convert
     * @return converted string
     * @see java.util.Properties
     */
    private String convertUnicodeToEncoded(String str) {
        int len = str.length();
        StringBuffer outBuffer = new StringBuffer(len * 2);

        for (int x = 0; x < len; x++) {
            char aChar = str.charAt(x);
            if ((aChar < 0x0020) || (aChar > 0x007e)) {
                outBuffer.append('\\');
                outBuffer.append('u');
                outBuffer.append(toHex((aChar >> 12) & 0xF));
                outBuffer.append(toHex((aChar >> 8) & 0xF));
                outBuffer.append(toHex((aChar >> 4) & 0xF));
                outBuffer.append(toHex(aChar & 0xF));
            } else {
                outBuffer.append(aChar);
            }
        }
        return outBuffer.toString();
    }

    /**
     * Converts a nibble to a hex character
     *
     * @param nibble the nibble to convert.
     * @return a converted character
     */
    private char toHex(int nibble) {
        char hexChar = HEX_DIGITS[(nibble & 0xF)];
        //if (!config.isUnicodeEscapeUppercase()) {
        return Character.toLowerCase(hexChar);
        //}
        //return hexChar;
    }

    /**
     * Appends a key to resource bundle content.
     *
     * @param text the resource bundle content so far
     * @param key the key to add
     * @param equalIndex the equal sign position
     * @param active is the key active or not
     */
    private void appendKey(StringBuffer text, String key, int equalIndex, boolean active) {

        if (!active) {
            text.append("##"); //$NON-NLS-1$
        }

        // Escape and persist the rest
        saveKey(text, key);
        // text.append(key);
        for (int i = 0; i < equalIndex - key.length(); i++) {
            text.append(' ');
        }
        if (isSpacesAroundEqualsEnabled()) {
            text.append(" = "); //$NON-NLS-1$
        } else {
            text.append("="); //$NON-NLS-1$
        }
    }

    // TODO onl test purpose
    private boolean isSpacesAroundEqualsEnabled() {
        // TODO Auto-generated method stub
        return false;
    }

    private void saveKey(StringBuffer buf, String str) {
        saveText(buf, str, SPECIAL_KEY_SAVE_CHARS);
    }

    private void saveValue(StringBuffer buf, String str) {
        saveText(buf, str, SPECIAL_VALUE_SAVE_CHARS);
    }

    /**
     * Saves some text in a given buffer after converting special characters.
     *
     * @param buf the buffer to store the text into
     * @param str the value to save
     * @param escapeChars characters to escape
     */
    private void saveText(final StringBuffer buf, final String str, final String escapeChars) {
        for (final char aChar : str.toCharArray()) {
            if (escapeChars.indexOf(aChar) != -1) {
                buf.append('\\');
            }
            buf.append(aChar);
        }
    }

    /**
     * Gets the position where the equal sign should be located for the given group.
     *
     * @param key resource bundle key
     * @param group resource bundle key group
     * @param messagesBundle resource bundle
     * @return position
     */
    private int getEqualIndex(final String key, final String group, final Bundle messagesBundle) {
        int equalIndex = -1;
        final boolean alignEquals = false;//config.isAlignEqualsEnabled();
        /*
         * final boolean groupKeys = PropertyPreferences.getInstance().isGroupKeysEnabled(); final boolean
         * groupAlignEquals = PropertyPreferences.getInstance().isGroupAlignEqualsEnabled(); // Exit now if we are not
         * aligning equals if (!alignEquals || (groupKeys && !groupAlignEquals) || (groupKeys && (group == null))) {
         * return key.length(); } // Get equal index final String[] keys = messagesBundle.getKeys(); for (final String
         * iterKey : keys) { if (!groupKeys || (groupAlignEquals && iterKey.startsWith(group))) { final int index =
         * iterKey.length(); if (index > equalIndex) { equalIndex = index; } } }_
         */
        return equalIndex;
    }
}
